package org.cocos2d.particlesystem;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.util.Properties;

import javax.microedition.khronos.opengles.GL10;
import javax.microedition.khronos.opengles.GL11;

import org.cocos2d.config.ccConfig;
import org.cocos2d.nodes.CCNode;
import org.cocos2d.types.CGPoint;
import org.cocos2d.types.ccBlendFunc;
import org.cocos2d.types.ccColor4F;
import org.cocos2d.types.ccPointSprite;

import android.view.Gravity;

/** @struct tCCParticle
 Structure that contains the values of each particle
 */
class CCParticle {
	class APart {
		CGPoint		dir;
		float		radialAccel;
		float		tangentialAccel;
	}

	// Mode B: radius mode
	class BPart {
		float		angle;
		float		degreesPerSecond;
		float		radius;
		float		deltaRadius;
	}
	
	CGPoint				pos;
	CGPoint				startPos;

	ccColor4F	color;
	ccColor4F	deltaColor;

	float		size;
	float		deltaSize;

	float		rotation;
	float		deltaRotation;

	float		timeToLive;

	APart		A;
	BPart		B;

}

// typedef void (*CC_UPDATE_PARTICLE_IMP)(id, SEL, tCCParticle*, CGPoint);


/** Particle System base class
 Attributes of a Particle System:
	- emmision rate of the particles
	- Gravity Mode (Mode A):
		- gravity
		- direction
		- speed +-  variance
		- tangential acceleration +- variance
		- radial acceleration +- variance
	- Radius Mode (Mode B):
		- startRadius +- variance
		- endRadius +- variance
		- rotate +- variance
	- Properties common to all modes:
		- life +- life variance
		- start spin +- variance
		- end spin +- variance
		- start size +- variance
		- end size +- variance
		- start color +- variance
		- end color +- variance
		- life +- variance
		- blending function
	- texture

 cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,
 cocos2d uses a another approach, but the results are almost identical. 
 
 cocos2d supports all the variables used by Particle Designer plus a bit more:
	- spinning particles (supported when using CCQuadParticleSystem)
	- tangential acceleration (Gravity mode)
	- radial acceleration (Gravity mode)
	- radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)
 
 It is possible to customize any of the above mentioned properties in runtime. Example:
 
 @code
	emitter.radialAccel = 15;
	emitter.startSpin = 0;
 @endcode
 
 */
class CCParticleSystem : CCNode <CCTextureProtocol>
{	
	// is the particle system active ?
	BOOL active;
	// duration in seconds of the system. -1 is infinity
	float duration;
	// time elapsed since the start of the system (in seconds)
	float elapsed;
	
	// position is from "superclass" CocosNode
	// Emitter centerOfGravity position
	CGPoint centerOfGravity;
	// Position variance
	CGPoint posVar;
	
	// The angle (direction) of the particles measured in degrees
	float angle;
	// Angle variance measured in degrees;
	float angleVar;
	
	// Different modes
	
	int emitterMode_;
	union {
		// Mode A:Gravity + Tangential Accel + Radial Accel
		struct {
			// gravity of the particles
			CGPoint gravity;

			// The speed the particles will have.
			float speed;
			// The speed variance
			float speedVar;

			// Tangential acceleration
			float tangentialAccel;
			// Tangential acceleration variance
			float tangentialAccelVar;

			// Radial acceleration
			float radialAccel;
			// Radial acceleration variance
			float radialAccelVar;
			} A;

		// Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)
		struct {
	
			// The starting radius of the particles
			float startRadius;
			// The starting radius variance of the particles
			float startRadiusVar;
			// The ending radius of the particles
			float endRadius;
			// The ending radius variance of the particles
			float endRadiusVar;			
			// Number of degress to rotate a particle around the source pos per second
			float rotatePerSecond;
			// Variance in degrees for rotatePerSecond
			float rotatePerSecondVar;
		} B;
	} mode;
	
	// start ize of the particles
	float startSize;
	// start Size variance
	float startSizeVar;
	// End size of the particle
	float endSize;
	// end size of variance
	float endSizeVar;
	
	// How many seconds will the particle live
	float life;
	// Life variance
	float lifeVar;
	
	// Start color of the particles
	ccColor4F startColor;
	// Start color variance
	ccColor4F startColorVar;
	// End color of the particles
	ccColor4F endColor;
	// End color variance
	ccColor4F endColorVar;
	
	// start angle of the particles
	float startSpin;
	// start angle variance
	float startSpinVar;
	// End angle of the particle
	float endSpin;
	// end angle ariance
	float endSpinVar;
	
	
	// Array of particles
	tCCParticle *particles;
	// Maximum particles
	int totalParticles;
	// Count of active particles
	int particleCount;
	
	// color modulate
//	BOOL colorModulate;
	
	// How many particles can be emitted per second
	float emissionRate;
	float emitCounter;
	
	// Texture of the particles
	CCTexture2D *texture_;
	// blend function
	ccBlendFunc	blendFunc_;

	// movment type: free or grouped
	tCCPositionType	positionType_;

	// Whether or not the node will be auto-removed when there are not particles
	BOOL	autoRemoveOnFinish_;

	//  particle idx
	int particleIdx;
	
	// Optimization
	CC_UPDATE_PARTICLE_IMP	updateParticleImp;
	SEL						updateParticleSel;

}


public abstract class ParticleSystem extends CCNode implements CCTextureProtocol {

	//* @enum
	
		/** The Particle emitter lives forever */
	public static final int	kCCParticleDurationInfinity = -1,

		/** The starting size of the particle is equal to the ending size */
	public static final int	kCCParticleStartSizeEqualToEndSize = -1,
		
		/** The starting radius of the particle is equal to the ending radius */
	public static final int	kCCParticleStartRadiusEqualToEndRadius = -1,

		// backward compatible
	public static final int	kParticleStartSizeEqualToEndSize = kCCParticleStartSizeEqualToEndSize,
	public static final int	kParticleDurationInfinity = kCCParticleDurationInfinity,


	//* @enum
	
		/** Gravity mode (A mode) */
	public static final int		kCCParticleModeGravity = 0,
		
		/** Radius mode (B mode) */
	public static final int			kCCParticleModeRadius = 1;


	/** @typedef tCCPositionType
	 possible types of particle positions
	 */
		/** If the emitter is repositioned, the living particles won't be repositioned */
	public static final int	kCCPositionTypeFree = 0;
		/** If the emitter is repositioned, the living particles will be repositioned too */
	public static final int	kCCPositionTypeGrouped;



	
    public static class Particle {
        CGPoint pos = new CGPoint();
        CGPoint startPos = new CGPoint();
        CGPoint dir = new CGPoint();
        float radialAccel;
        float tangentialAccel;
        ccColor4F color = new ccColor4F();
        ccColor4F deltaColor = new ccColor4F();
        float size;
        float life;
    }

    protected int id;

    // is the particle system active ?
    protected boolean active;

    // duration in seconds of the system. -1 is infinity
    protected float duration;

    // time elapsed since the start of the system (in seconds)
    protected float elapsed;

    /// Gravity of the particles
    protected CGPoint gravity = CGPoint.zero();

    // position is from "superclass" CocosNode
    // Emitter source position
    protected CGPoint source = CGPoint.zero();

    // Position variance
    protected CGPoint posVar = CGPoint.zero();

    // The angle (direction) of the particles measured in degrees
    protected float angle;
    // Angle variance measured in degrees;
    protected float angleVar;

    // The speed the particles will have.
    protected float speed;
    // The speed variance
    protected float speedVar;

    // Tangential acceleration
    protected float tangentialAccel;

    // Tangential acceleration variance
    protected float tangentialAccelVar;

    // Radial acceleration
    protected float radialAccel;

    // Radial acceleration variance
    protected float radialAccelVar;

    // Size of the particles
    protected float size;

    // Size variance
    protected float sizeVar;

    // How many seconds will the particle live
    protected float life;
    // Life variance
    protected float lifeVar;

    // Start color of the particles
    protected ccColor4F startColor = new ccColor4F();

    // Start color variance
    protected ccColor4F startColorVar = new ccColor4F();

    // End color of the particles
    protected ccColor4F endColor = new ccColor4F();

    // End color variance
    protected ccColor4F endColorVar = new ccColor4F();

    // Array of particles
    protected Particle particles[];

    // Maximum particles
    protected int totalParticles;

    // Count of active particles
    protected int particleCount;

    // additive color or blend
    protected boolean blendAdditive;
    // color modulate
    protected boolean colorModulate;

    // How many particles can be emitted per second
    protected float emissionRate;
    protected float emitCounter;

    // Texture of the particles
    protected CCTexture2D texture;

    // Array of (x,y,size,color)
    ccPointSprite vertices[];

    // Array of colors
    //CCColorF	colors[];

    // Array of pointsizes
    //float pointsizes[];

    // vertices buffer id
    protected int verticesID = -1;

    // colors buffer id
    protected int colorsID;

    //  particle idx
    protected int particleIdx;

    /**
     * Is the emitter active
     */

    public boolean getActive() {
        return active;
    }

    /**
     * Quantity of particles that are being simulated at the moment
     */

    public int getParticleCount() {
        return particleCount;
    }

    /**
     * Gravity value
     */

    public CGPoint getGravity() {
        return gravity;
    }

    public void setGravity(CGPoint gravity) {
        this.gravity = gravity;
    }

    /**
     * How many seconds the emitter wil run. -1 means 'forever'
     */

    public float getDuration() {
        return duration;
    }

    public void setDuration(float duration) {
        this.duration = duration;
    }

    /**
     * Source location of particles respective to emitter location
     */

    public CGPoint getSource() {
        return source;
    }

    public void setSource(CGPoint source) {
        this.source = source;
    }

    /**
     * Position variance of the emitter
     */
    public CGPoint getPosVar() {
        return posVar;
    }


    /**
     * life, and life variation of each particle
     */
    public float getLife() {
        return life;
    }

    public void setLife(float life) {
        this.life = life;
    }

//    /** life variance of each particle */
//    protected float lifeVar;
//    /** angle and angle variation of each particle */
//    protected float angle;
//    /** angle variance of each particle */
//    protected float angleVar;
//    /** speed of each particle */
//    protected float speed;
//    /** speed variance of each particle */
//    protected float speedVar;
//    /** tangential acceleration of each particle */
//    protected float tangentialAccel;
//    /** tangential acceleration variance of each particle */
//    protected float tangentialAccelVar;
//    /** radial acceleration of each particle */
//    protected float radialAccel;
//    /** radial acceleration variance of each particle */
//    protected float radialAccelVar;
//    /** size in pixels of each particle */
//    protected float size;
//    /** size variance in pixels of each particle */
//    protected float sizeVar;
//    /** start color of each particle */
//    protected CCColorF startColor;
//    /** start color variance of each particle */
//    protected CCColorF startColorVar;
//    /** end color and end color variation of each particle */
//    protected CCColorF endColor;
//    /** end color variance of each particle */
//    protected CCColorF endColorVar;
//    /** emission rate of the particles */
//    protected float emissionRate;
//    /** maximum particles of the system */
//    protected int totalParticles;

    public static final int kPositionTypeFree = 1;
    public static final int kPositionTypeGrouped = 2;
    
    // movement type: free or grouped
    private	int positionType_;

    public int getPositionType() {
        return positionType_;
    }

    public void setPositionType(int type) {
        positionType_ = type;
    }

    
    /**
     * texture used to render the particles
     */

    public CCTexture2D getTexture() {
        return texture;
    }

    public void setTexture(CCTexture2D tex) {
        this.texture = tex;
    }


    private FloatBuffer mVertices;
    private FloatBuffer mPointSizes;
    private FloatBuffer mColors;


    //! Initializes a system with a fixed number of particles
    protected ParticleSystem(int numberOfParticles) {
        totalParticles = numberOfParticles;

        particles = new Particle[totalParticles];
        vertices = new ccPointSprite[totalParticles];


        for (int i = 0; i < totalParticles; i++) {
            particles[i] = new Particle();
            vertices[i]  = new ccPointSprite();
        }

        // default, active
        active = true;

        // default: additive
        blendAdditive = false;

        // default: modulate
        //colorModulate = true;

        ByteBuffer vfb = ByteBuffer.allocateDirect(4 * 2 * totalParticles);
        vfb.order(ByteOrder.nativeOrder());
        mVertices = vfb.asFloatBuffer();

        ByteBuffer sfb = ByteBuffer.allocateDirect(4 * 1 * totalParticles);
        sfb.order(ByteOrder.nativeOrder());
        mPointSizes = sfb.asFloatBuffer();

        ByteBuffer cfb = ByteBuffer.allocateDirect(4 * 4 * totalParticles);
        cfb.order(ByteOrder.nativeOrder());
        mColors = cfb.asFloatBuffer();

        // default movement type;
        positionType_ = kPositionTypeFree;

        schedule("step");

    }

    //! Add a particle to the emitter
    public boolean addParticle() {
        if (isFull())
            return false;

        Particle particle = particles[particleCount];

        initParticle(particle);
        particleCount++;

        return true;

    }

    private void initParticle(Particle particle) {
        CGPoint v = CGPoint.zero();

        // position
        particle.pos.x = (int) (source.x + posVar.x * CCRANDOM_MINUS1_1());
        particle.pos.y = (int) (source.y + posVar.y * CCRANDOM_MINUS1_1());

        // direction
        float a = CC_DEGREES_TO_RADIANS(angle + angleVar * CCRANDOM_MINUS1_1());
        v.y = (float)Math.sin(a);
        v.x = (float)Math.cos(a);
        float s = speed + speedVar * CCRANDOM_MINUS1_1();
        particle.dir = CGPoint.ccpMult(v, s);

        // radial accel
        particle.radialAccel = radialAccel + radialAccelVar * CCRANDOM_MINUS1_1();

        // tangential accel
        particle.tangentialAccel = tangentialAccel + tangentialAccelVar * CCRANDOM_MINUS1_1();

        // life
        particle.life = life + lifeVar * CCRANDOM_MINUS1_1();

        // Color
        ccColor4F start = new ccColor4F();
        start.r = startColor.r + startColorVar.r * CCRANDOM_MINUS1_1();
        start.g = startColor.g + startColorVar.g * CCRANDOM_MINUS1_1();
        start.b = startColor.b + startColorVar.b * CCRANDOM_MINUS1_1();
        start.a = startColor.a + startColorVar.a * CCRANDOM_MINUS1_1();

        ccColor4F end = new ccColor4F();
        end.r = endColor.r + endColorVar.r * CCRANDOM_MINUS1_1();
        end.g = endColor.g + endColorVar.g * CCRANDOM_MINUS1_1();
        end.b = endColor.b + endColorVar.b * CCRANDOM_MINUS1_1();
        end.a = endColor.a + endColorVar.a * CCRANDOM_MINUS1_1();

        particle.color = start;
        particle.deltaColor.r = (end.r - start.r) / particle.life;
        particle.deltaColor.g = (end.g - start.g) / particle.life;
        particle.deltaColor.b = (end.b - start.b) / particle.life;
        particle.deltaColor.a = (end.a - start.a) / particle.life;

        // size
        particle.size = size + sizeVar * CCRANDOM_MINUS1_1();

        // position
        if( positionType_ == kPositionTypeFree ) {
            particle.startPos = convertToWorldSpace(0, 0);
        } else {
            particle.startPos = getPosition();
        }

    }


    //! Initializes a particle
//    public ParticleSystem(Particle particle)
//    {
//    }

    public void step(float dt) {
        if (active && emissionRate != 0) {
            float rate = 1.0f / emissionRate;
            emitCounter += dt;
            while (particleCount < totalParticles && emitCounter > rate) {
                addParticle();
                emitCounter -= rate;
            }

            elapsed += dt;
            if (duration != -1 && duration < elapsed)
                stopSystem();
        }

        particleIdx = 0;

        while (particleIdx < particleCount) {
            Particle p = particles[particleIdx];

            if (p.life > 0) {

                CGPoint tmp, radial, tangential;

                radial = CGPoint.zero();
                // radial acceleration
                if (p.pos.x != 9 || p.pos.y != 0)
                    radial = CGPoint.ccpNormalize(p.pos);
                tangential = radial;
                radial = CGPoint.ccpMult(radial, p.radialAccel);

                // tangential acceleration
                float newy = tangential.x;
                tangential.x = -tangential.y;
                tangential.y = newy;
                tangential = CGPoint.ccpMult(tangential, p.tangentialAccel);

                // (gravity + radial + tangential) * dt
                tmp = CGPoint.ccpAdd(CGPoint.ccpAdd(radial, tangential), gravity);
                tmp = CGPoint.ccpMult(tmp, dt);
                p.dir = CGPoint.ccpAdd(p.dir, tmp);
                tmp = CGPoint.ccpMult(p.dir, dt);
                p.pos = CGPoint.ccpAdd(p.pos, tmp);

                p.color.r += (p.deltaColor.r * dt);
                p.color.g += (p.deltaColor.g * dt);
                p.color.b += (p.deltaColor.b * dt);
                p.color.a += (p.deltaColor.a * dt);

                p.life -= dt;

                // place vertices and colos in array
                vertices[particleIdx].x = p.pos.x;
                vertices[particleIdx].y = p.pos.y;

                // TODO: Remove when glPointSizePointerOES is fixed
                vertices[particleIdx].size = p.size;
                vertices[particleIdx].colors = new ccColor4F(p.color);

                // update particle counter
                particleIdx++;

            } else {
                // life < 0
                if (particleIdx != particleCount - 1)
                    particles[particleIdx] = particles[particleCount - 1];
                particleCount--;
            }
        }
    }


    //! stop emitting particles. Running particles will continue to run until they die
    public void stopSystem() {
        active = false;
        elapsed = duration;
        emitCounter = 0;
    }

    //! Kill all living particles.
    public void resetSystem() {
        active = true;
        elapsed = 0;
        for (particleIdx = 0; particleIdx < particleCount; ++particleIdx) {
            Particle p = particles[particleIdx];
            p.life = 0;
        }
    }

    public void draw(GL10 gl) {
        if (verticesID <= 0) {
            int name[] = new int[1];
            ((GL11) gl).glGenBuffers(1, name, 0);
            ((GL11) gl).glBindBuffer(GL11.GL_ARRAY_BUFFER, verticesID);
            // TODO: Remove when glPointSizePointerOES is fixed
//            gl.glBufferData(GL_ARRAY_BUFFER, 4*7*totalParticles, vertices, GL_DYNAMIC_DRAW);
            ((GL11) gl).glBindBuffer(GL11.GL_ARRAY_BUFFER, 0);
        }

        gl.glEnable(GL_TEXTURE_2D);
        gl.glBindTexture(GL_TEXTURE_2D, texture.name());

        gl.glEnable(GL11.GL_POINT_SPRITE_OES);
        ((GL11) gl).glTexEnvi(GL11.GL_POINT_SPRITE_OES, GL11.GL_COORD_REPLACE_OES, GL10.GL_TRUE);

        gl.glEnableClientState(GL_VERTEX_ARRAY);
        ((GL11) gl).glBindBuffer(GL11.GL_ARRAY_BUFFER, verticesID);

        for (int i = 0; i < totalParticles; i++) {
            mVertices.put(vertices[i].x);
            mVertices.put(vertices[i].y);
            mPointSizes.put(vertices[i].size);
            mColors.put(vertices[i].colors.r);
            mColors.put(vertices[i].colors.g);
            mColors.put(vertices[i].colors.b);
            mColors.put(vertices[i].colors.a);
        }
        mVertices.position(0);
        mPointSizes.position(0);
        mColors.position(0);

        // TODO: Remove when glPointSizePointerOES is fixed
        //gl.glVertexPointer(2, GL_FLOAT, 7*4, 0);
        gl.glVertexPointer(2, GL_FLOAT, 0, mVertices);

        gl.glEnableClientState(GL11.GL_POINT_SIZE_ARRAY_OES);
        // TODO: Remove when glPointSizePointerOES is fixed
        //gl.glPointSizePointerOES(GL_FLOAT, 7*4, 4*2);
        ((GL11) gl).glPointSizePointerOES(GL_FLOAT, 0, mPointSizes);

        gl.glEnableClientState(GL_COLOR_ARRAY);
        // TODO: Remove when glPointSizePointerOES is fixed
        //gl.glColorPointer(4, GL_FLOAT, 7*4, 4*3);
        gl.glColorPointer(4, GL_FLOAT, 0, mColors);

        if (blendAdditive)
            gl.glBlendFunc(GL_SRC_ALPHA, GL_ONE);
        else
            gl.glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        // save color mode
        //glGetTexEnviv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &colorMode);

        gl.glDrawArrays(GL_POINTS, 0, particleIdx);

        // restore blend state
        gl.glBlendFunc(ccConfig.CC_BLEND_SRC, ccConfig.CC_BLEND_DST);

        // restore color mode
        //glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, colorMode);

        // unbind VBO buffer
        ((GL11) gl).glBindBuffer(GL11.GL_ARRAY_BUFFER, 0);

        gl.glDisableClientState(GL_VERTEX_ARRAY);
        gl.glDisableClientState(GL11.GL_POINT_SIZE_ARRAY_OES);
        gl.glDisableClientState(GL_COLOR_ARRAY);
        gl.glDisable(GL_TEXTURE_2D);
        gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }

    //! whether or not the system is full
    public boolean isFull() {
        return particleCount == totalParticles;
    }

}

/** Is the emitter active */
@property (nonatomic,readonly) BOOL active;
/** Quantity of particles that are being simulated at the moment */
@property (nonatomic,readonly) int	particleCount;
/** How many seconds the emitter wil run. -1 means 'forever' */
@property (nonatomic,readwrite,assign) float duration;
/** centerOfGravity of the emitter */
@property (nonatomic,readwrite,assign) CGPoint centerOfGravity;
/** Position variance of the emitter */
@property (nonatomic,readwrite,assign) CGPoint posVar;
/** life, and life variation of each particle */
@property (nonatomic,readwrite,assign) float life;
/** life variance of each particle */
@property (nonatomic,readwrite,assign) float lifeVar;
/** angle and angle variation of each particle */
@property (nonatomic,readwrite,assign) float angle;
/** angle variance of each particle */
@property (nonatomic,readwrite,assign) float angleVar;

/** Gravity value. Only available in 'Gravity' mode. */
@property (nonatomic,readwrite,assign) CGPoint gravity;
/** speed of each particle. Only available in 'Gravity' mode.  */
@property (nonatomic,readwrite,assign) float speed;
/** speed variance of each particle. Only available in 'Gravity' mode. */
@property (nonatomic,readwrite,assign) float speedVar;
/** tangential acceleration of each particle. Only available in 'Gravity' mode. */
@property (nonatomic,readwrite,assign) float tangentialAccel;
/** tangential acceleration variance of each particle. Only available in 'Gravity' mode. */
@property (nonatomic,readwrite,assign) float tangentialAccelVar;
/** radial acceleration of each particle. Only available in 'Gravity' mode. */
@property (nonatomic,readwrite,assign) float radialAccel;
/** radial acceleration variance of each particle. Only available in 'Gravity' mode. */
@property (nonatomic,readwrite,assign) float radialAccelVar;

/** The starting radius of the particles. Only available in 'Radius' mode. */
@property (nonatomic,readwrite,assign) float startRadius;
/** The starting radius variance of the particles. Only available in 'Radius' mode. */
@property (nonatomic,readwrite,assign) float startRadiusVar;
/** The ending radius of the particles. Only available in 'Radius' mode. */
@property (nonatomic,readwrite,assign) float endRadius;
/** The ending radius variance of the particles. Only available in 'Radius' mode. */
@property (nonatomic,readwrite,assign) float endRadiusVar;			
/** Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode. */
@property (nonatomic,readwrite,assign) float rotatePerSecond;
/** Variance in degrees for rotatePerSecond. Only available in 'Radius' mode. */
@property (nonatomic,readwrite,assign) float rotatePerSecondVar;

/** start size in pixels of each particle */
@property (nonatomic,readwrite,assign) float startSize;
/** size variance in pixels of each particle */
@property (nonatomic,readwrite,assign) float startSizeVar;
/** end size in pixels of each particle */
@property (nonatomic,readwrite,assign) float endSize;
/** end size variance in pixels of each particle */
@property (nonatomic,readwrite,assign) float endSizeVar;
/** start color of each particle */
@property (nonatomic,readwrite,assign) ccColor4F startColor;
/** start color variance of each particle */
@property (nonatomic,readwrite,assign) ccColor4F startColorVar;
/** end color and end color variation of each particle */
@property (nonatomic,readwrite,assign) ccColor4F endColor;
/** end color variance of each particle */
@property (nonatomic,readwrite,assign) ccColor4F endColorVar;
//* initial angle of each particle
@property (nonatomic,readwrite,assign) float startSpin;
//* initial angle of each particle
@property (nonatomic,readwrite,assign) float startSpinVar;
//* initial angle of each particle
@property (nonatomic,readwrite,assign) float endSpin;
//* initial angle of each particle
@property (nonatomic,readwrite,assign) float endSpinVar;
/** emission rate of the particles */
@property (nonatomic,readwrite,assign) float emissionRate;
/** maximum particles of the system */
@property (nonatomic,readwrite,assign) int totalParticles;
/** conforms to CocosNodeTexture protocol */
@property (nonatomic,readwrite, retain) CCTexture2D * texture;
/** conforms to CocosNodeTexture protocol */
@property (nonatomic,readwrite) ccBlendFunc blendFunc;
/** whether or not the particles are using blend additive.
 If enabled, the following blending function will be used.
 @code
	source blend function = GL_SRC_ALPHA;
	dest blend function = GL_ONE;
 @endcode
 */
@property (nonatomic,readwrite) BOOL blendAdditive;
/** particles movement type: Free or Grouped
 @since v0.8
 */
@property (nonatomic,readwrite) tCCPositionType positionType;
/** whether or not the node will be auto-removed when it has no particles left.
 By default it is NO.
 @since v0.8
 */
@property (nonatomic,readwrite) BOOL autoRemoveOnFinish;
/** Switch between different kind of emitter modes:
   - kCCParticleModeGravity: uses gravity, speed, radial and tangential acceleration
   - kCCParticleModeRadius: uses radius movement + rotation
 */
@property (nonatomic,readwrite) int emitterMode;

/** creates an initializes a CCParticleSystem from a plist file.
 This plist files can be creted manually or with Particle Designer:
	http://particledesigner.71squared.com/
 @since v0.99.3
 */
+(id) particleWithFile:(NSString*)plistFile;

/** initializes a CCParticleSystem from a plist file.
 This plist files can be creted manually or with Particle Designer:
	http://particledesigner.71squared.com/
 @since v0.99.3
 */
-(id) initWithFile:(NSString*) plistFile;

/** initializes a CCQuadParticleSystem from a NSDictionary.
 @since v0.99.3
 */
-(id) initWithDictionary:(NSDictionary*)dictionary;

//! Initializes a system with a fixed number of particles
-(id) initWithTotalParticles:(int) numberOfParticles;
//! Add a particle to the emitter
-(BOOL) addParticle;
//! Initializes a particle
-(void) initParticle: (tCCParticle*) particle;
//! stop emitting particles. Running particles will continue to run until they die
-(void) stopSystem;
//! Kill all living particles.
-(void) resetSystem;
//! whether or not the system is full
-(BOOL) isFull;

//! should be overriden by subclasses
-(void) updateQuadWithParticle:(tCCParticle*)particle newPosition:(CGPoint)pos;
//! should be overriden by subclasses
-(void) postStep;

@end


// ideas taken from:
//	 . The ocean spray in your face [Jeff Lander]
//		http://www.double.co.nz/dust/col0798.pdf
//	 . Building an Advanced Particle System [John van der Burg]
//		http://www.gamasutra.com/features/20000623/vanderburg_01.htm
//   . LOVE game engine
//		http://love2d.org/
//
//
// Radius mode support, from 71 squared
//		http://particledesigner.71squared.com/
//
// IMPORTANT: Particle Designer is supported by cocos2d, but
// 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,
//  cocos2d uses a another approach, but the results are almost identical. 
//

// opengl
#import <OpenGLES/ES1/gl.h>

// cocos2d
#import "ccConfig.h"
#if CC_ENABLE_PROFILERS
#import "Support/CCProfiling.h"
#endif
#import "CCParticleSystem.h"
#import "CCTextureCache.h"
#import "ccMacros.h"

// support
#import "Support/OpenGL_Internal.h"
#import "Support/CGPointExtension.h"
#import "Support/base64.h"
#import "Support/ZipUtils.h"
#import "Support/CCFileUtils.h"

@implementation CCParticleSystem
@synthesize active, duration;
@synthesize centerOfGravity, posVar;
@synthesize particleCount;
@synthesize life, lifeVar;
@synthesize angle, angleVar;
@synthesize startColor, startColorVar, endColor, endColorVar;
@synthesize startSpin, startSpinVar, endSpin, endSpinVar;
@synthesize emissionRate;
@synthesize totalParticles;
@synthesize startSize, startSizeVar;
@synthesize endSize, endSizeVar;
@synthesize blendFunc = blendFunc_;
@synthesize positionType = positionType_;
@synthesize autoRemoveOnFinish = autoRemoveOnFinish_;
@synthesize emitterMode = emitterMode_;


+(id) particleWithFile:(NSString*) plistFile
{
	return [[[self alloc] initWithFile:plistFile] autorelease];
}

-(id) init {
	NSException* myException = [NSException
								exceptionWithName:@"Particle.init"
								reason:@"Particle.init shall not be called. Use initWithTotalParticles instead."
								userInfo:nil];
	@throw myException;	
}

-(id) initWithFile:(NSString *)plistFile
{
	NSString *path = [CCFileUtils fullPathFromRelativePath:plistFile];
	NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];
	
	NSAssert( dict != nil, @"Particles: file not found");
	return [self initWithDictionary:dict];
}

-(id) initWithDictionary:(NSDictionary *)dictionary
{
	int maxParticles = [[dictionary valueForKey:@"maxParticles"] intValue];
	// self, not super
	if ((self=[self initWithTotalParticles:maxParticles] ) ) {
		
		// angle
		angle = [[dictionary valueForKey:@"angle"] floatValue];
		angleVar = [[dictionary valueForKey:@"angleVariance"] floatValue];
		
		// duration
		duration = [[dictionary valueForKey:@"duration"] floatValue];
		
		// blend function 
		blendFunc_.src = [[dictionary valueForKey:@"blendFuncSource"] intValue];
		blendFunc_.dst = [[dictionary valueForKey:@"blendFuncDestination"] intValue];
		
		// color
		float r,g,b,a;
		
		r = [[dictionary valueForKey:@"startColorRed"] floatValue];
		g = [[dictionary valueForKey:@"startColorGreen"] floatValue];
		b = [[dictionary valueForKey:@"startColorBlue"] floatValue];
		a = [[dictionary valueForKey:@"startColorAlpha"] floatValue];
		startColor = (ccColor4F) {r,g,b,a};
		
		r = [[dictionary valueForKey:@"startColorVarianceRed"] floatValue];
		g = [[dictionary valueForKey:@"startColorVarianceGreen"] floatValue];
		b = [[dictionary valueForKey:@"startColorVarianceBlue"] floatValue];
		a = [[dictionary valueForKey:@"startColorVarianceAlpha"] floatValue];
		startColorVar = (ccColor4F) {r,g,b,a};
		
		r = [[dictionary valueForKey:@"finishColorRed"] floatValue];
		g = [[dictionary valueForKey:@"finishColorGreen"] floatValue];
		b = [[dictionary valueForKey:@"finishColorBlue"] floatValue];
		a = [[dictionary valueForKey:@"finishColorAlpha"] floatValue];
		endColor = (ccColor4F) {r,g,b,a};
		
		r = [[dictionary valueForKey:@"finishColorVarianceRed"] floatValue];
		g = [[dictionary valueForKey:@"finishColorVarianceGreen"] floatValue];
		b = [[dictionary valueForKey:@"finishColorVarianceBlue"] floatValue];
		a = [[dictionary valueForKey:@"finishColorVarianceAlpha"] floatValue];
		endColorVar = (ccColor4F) {r,g,b,a};
		
		// particle size
		startSize = [[dictionary valueForKey:@"startParticleSize"] floatValue];
		startSizeVar = [[dictionary valueForKey:@"startParticleSizeVariance"] floatValue];
		endSize = [[dictionary valueForKey:@"finishParticleSize"] floatValue];
		endSizeVar = [[dictionary valueForKey:@"finishParticleSizeVariance"] floatValue];
		
		
		// position
		float x = [[dictionary valueForKey:@"sourcePositionx"] floatValue];
		float y = [[dictionary valueForKey:@"sourcePositiony"] floatValue];
		position_ = ccp(x,y);
		posVar.x = [[dictionary valueForKey:@"sourcePositionVariancex"] floatValue];
		posVar.y = [[dictionary valueForKey:@"sourcePositionVariancey"] floatValue];
				
		
		emitterMode_ = [[dictionary valueForKey:@"emitterType"] intValue];

		// Mode A: Gravity + tangential accel + radial accel
		if( emitterMode_ == kCCParticleModeGravity ) {
			// gravity
			mode.A.gravity.x = [[dictionary valueForKey:@"gravityx"] floatValue];
			mode.A.gravity.y = [[dictionary valueForKey:@"gravityy"] floatValue];
			
			//
			// speed
			mode.A.speed = [[dictionary valueForKey:@"speed"] floatValue];
			mode.A.speedVar = [[dictionary valueForKey:@"speedVariance"] floatValue];
			
			// radial acceleration
			mode.A.radialAccel = [[dictionary valueForKey:@"radialAcceleration"] floatValue];
			mode.A.radialAccelVar = [[dictionary valueForKey:@"radialAccelVariance"] floatValue];
			
			// tangential acceleration
			mode.A.tangentialAccel = [[dictionary valueForKey:@"tangentialAcceleration"] floatValue];
			mode.A.tangentialAccelVar = [[dictionary valueForKey:@"tangentialAccelVariance"] floatValue];
		}
		
		
		// or Mode B: radius movement
		else if( emitterMode_ == kCCParticleModeRadius ) {
			float maxRadius = [[dictionary valueForKey:@"maxRadius"] floatValue];
			float maxRadiusVar = [[dictionary valueForKey:@"maxRadiusVariance"] floatValue];
			float minRadius = [[dictionary valueForKey:@"minRadius"] floatValue];
			
			mode.B.startRadius = maxRadius;
			mode.B.startRadiusVar = maxRadiusVar;
			mode.B.endRadius = minRadius;
			mode.B.endRadiusVar = 0;
			mode.B.rotatePerSecond = [[dictionary valueForKey:@"rotatePerSecond"] floatValue];
			mode.B.rotatePerSecondVar = [[dictionary valueForKey:@"rotatePerSecondVariance"] floatValue];

		} else {
			NSAssert( NO, @"Invalid emitterType in config file");
		}
		
		// life span
		life = [[dictionary valueForKey:@"particleLifespan"] floatValue];
		lifeVar = [[dictionary valueForKey:@"particleLifespanVariance"] floatValue];				
		
		// emission Rate
		emissionRate = totalParticles/life;

		// texture		
		// Try to get the texture from the cache
		NSString *textureName = [dictionary valueForKey:@"textureFileName"];
		NSString *textureData = [dictionary valueForKey:@"textureImageData"];

		self.texture = [[CCTextureCache sharedTextureCache] addImage:textureName];

		if ( ! texture_ && textureData) {
			
			// if it fails, try to get it from the base64-gzipped data			
			unsigned char *buffer = NULL;
			int len = base64Decode((unsigned char*)[textureData UTF8String], [textureData length], &buffer);
			NSAssert( buffer != NULL, @"CCParticleSystem: error decoding textureImageData");
				
			unsigned char *deflated = NULL;
			int deflatedLen = inflateMemory(buffer, len, &deflated);
			free( buffer );
				
			NSAssert( deflated != NULL, @"CCParticleSystem: error ungzipping textureImageData");
			NSData *data = [[NSData alloc] initWithBytes:deflated length:deflatedLen];
			UIImage *image = [[UIImage alloc] initWithData:data];
			
			self.texture = [[CCTextureCache sharedTextureCache] addCGImage:[image CGImage] forKey:textureName];
			[data release];
			[image release];
		}
		
		NSAssert( [self texture] != NULL, @"CCParticleSystem: error loading the texture");
		
	}
	
	return self;
}

-(id) initWithTotalParticles:(int) numberOfParticles
{
	if( (self=[super init]) ) {

		totalParticles = numberOfParticles;
		
		particles = calloc( totalParticles, sizeof(tCCParticle) );

		if( ! particles ) {
			NSLog(@"Particle system: not enough memory");
			[self release];
			return nil;
		}
		
		// default, active
		active = YES;
		
		// default blend function
		blendFunc_ = (ccBlendFunc) { CC_BLEND_SRC, CC_BLEND_DST };
		
		// default movement type;
		positionType_ = kCCPositionTypeFree;
		
		// by default be in mode A:
		emitterMode_ = kCCParticleModeGravity;
				
		// default: modulate
		// XXX: not used
	//	colorModulate = YES;
		
		autoRemoveOnFinish_ = NO;

		// profiling
#if CC_ENABLE_PROFILERS
		_profilingTimer = [[CCProfiler timerWithName:@"particle system" andInstance:self] retain];
#endif
		
		// Optimization: compile udpateParticle method
		updateParticleSel = @selector(updateQuadWithParticle:newPosition:);
		updateParticleImp = (CC_UPDATE_PARTICLE_IMP) [self methodForSelector:updateParticleSel];

		// udpate after action in run!
		[self scheduleUpdateWithPriority:1];
		
	}

	return self;
}

-(void) dealloc
{
	free( particles );

	[texture_ release];
	// profiling
#if CC_ENABLE_PROFILERS
	[CCProfiler releaseTimer:_profilingTimer];
#endif
	
	[super dealloc];
}

-(BOOL) addParticle
{
	if( [self isFull] )
		return NO;
	
	tCCParticle * particle = &particles[ particleCount ];
		
	[self initParticle: particle];		
	particleCount++;
				
	return YES;
}

-(void) initParticle: (tCCParticle*) particle
{

	// timeToLive
	// no negative life. prevent division by 0
	particle->timeToLive = MAX(0, life + lifeVar * CCRANDOM_MINUS1_1() );

	// position
	particle->pos.x = centerOfGravity.x + posVar.x * CCRANDOM_MINUS1_1();
	particle->pos.y = centerOfGravity.y + posVar.y * CCRANDOM_MINUS1_1();
	
	// Color
	ccColor4F start;
	start.r = MIN(1, MAX(0, startColor.r + startColorVar.r * CCRANDOM_MINUS1_1() ) );
	start.g = MIN(1, MAX(0, startColor.g + startColorVar.g * CCRANDOM_MINUS1_1() ) );
	start.b = MIN(1, MAX(0, startColor.b + startColorVar.b * CCRANDOM_MINUS1_1() ) );
	start.a = MIN(1, MAX(0, startColor.a + startColorVar.a * CCRANDOM_MINUS1_1() ) );
	
	ccColor4F end;
	end.r = MIN(1, MAX(0, endColor.r + endColorVar.r * CCRANDOM_MINUS1_1() ) );
	end.g = MIN(1, MAX(0, endColor.g + endColorVar.g * CCRANDOM_MINUS1_1() ) );
	end.b = MIN(1, MAX(0, endColor.b + endColorVar.b * CCRANDOM_MINUS1_1() ) );
	end.a = MIN(1, MAX(0, endColor.a + endColorVar.a * CCRANDOM_MINUS1_1() ) );
	
	particle->color = start;
	particle->deltaColor.r = (end.r - start.r) / particle->timeToLive;
	particle->deltaColor.g = (end.g - start.g) / particle->timeToLive;
	particle->deltaColor.b = (end.b - start.b) / particle->timeToLive;
	particle->deltaColor.a = (end.a - start.a) / particle->timeToLive;
	
	// size
	float startS = MAX(0, startSize + startSizeVar * CCRANDOM_MINUS1_1() ); // no negative size
	
	particle->size = startS;
	if( endSize == kCCParticleStartSizeEqualToEndSize )
		particle->deltaSize = 0;
	else {
		float endS = endSize + endSizeVar * CCRANDOM_MINUS1_1();
		endS = MAX(0, endS);
		particle->deltaSize = (endS - startS) / particle->timeToLive;
	}
	
	// rotation
	float startA = startSpin + startSpinVar * CCRANDOM_MINUS1_1();
	float endA = endSpin + endSpinVar * CCRANDOM_MINUS1_1();
	particle->rotation = startA;
	particle->deltaRotation = (endA - startA) / particle->timeToLive;
	
	// position
	if( positionType_ == kCCPositionTypeFree )
		particle->startPos = [self convertToWorldSpace:CGPointZero];
	
	// direction
	float a = CC_DEGREES_TO_RADIANS( angle + angleVar * CCRANDOM_MINUS1_1() );	
	
	// Mode Gravity: A
	if( emitterMode_ == kCCParticleModeGravity ) {

		
		CGPoint v;
		v.y = sinf( a );
		v.x = cosf( a );
		float s = mode.A.speed + mode.A.speedVar * CCRANDOM_MINUS1_1();
		
		// direction
		particle->mode.A.dir = ccpMult( v, s );
		
		// radial accel
		particle->mode.A.radialAccel = mode.A.radialAccel + mode.A.radialAccelVar * CCRANDOM_MINUS1_1();
		
		// tangential accel
		particle->mode.A.tangentialAccel = mode.A.tangentialAccel + mode.A.tangentialAccelVar * CCRANDOM_MINUS1_1();
	}
	
	// Mode Radius: B
	else {
		// Set the default diameter of the particle from the source position
		float startRadius = mode.B.startRadius + mode.B.startRadiusVar * CCRANDOM_MINUS1_1();
		float endRadius = mode.B.endRadius + mode.B.endRadiusVar * CCRANDOM_MINUS1_1();

		particle->mode.B.radius = startRadius;

		if( mode.B.endRadius == kCCParticleStartRadiusEqualToEndRadius )
			particle->mode.B.deltaRadius = 0;
		else
			particle->mode.B.deltaRadius = (endRadius - startRadius) / particle->timeToLive;
	
		particle->mode.B.angle = a;
		particle->mode.B.degreesPerSecond = CC_DEGREES_TO_RADIANS(mode.B.rotatePerSecond + mode.B.rotatePerSecondVar * CCRANDOM_MINUS1_1());
		
	}	
}

-(void) stopSystem
{
	active = NO;
	elapsed = duration;
	emitCounter = 0;
}

-(void) resetSystem
{
	active = YES;
	elapsed = 0;
	for(particleIdx = 0; particleIdx < particleCount; ++particleIdx) {
		tCCParticle *p = &particles[particleIdx];
		p->timeToLive = 0;
	}
}

-(BOOL) isFull
{
	return (particleCount == totalParticles);
}

#pragma mark ParticleSystem - MainLoop
-(void) update: (ccTime) dt
{
	if( active && emissionRate ) {
		float rate = 1.0f / emissionRate;
		emitCounter += dt;
		while( particleCount < totalParticles && emitCounter > rate ) {
			[self addParticle];
			emitCounter -= rate;
		}
		
		elapsed += dt;
		if(duration != -1 && duration < elapsed)
			[self stopSystem];
	}
	
	particleIdx = 0;
	
	
#if CC_ENABLE_PROFILERS
	CCProfilingBeginTimingBlock(_profilingTimer);
#endif
	
	
	CGPoint currentPosition = CGPointZero;
	if( positionType_ == kCCPositionTypeFree )
		currentPosition = [self convertToWorldSpace:CGPointZero];
	
	while( particleIdx < particleCount )
	{
		tCCParticle *p = &particles[particleIdx];
		
		// life
		p->timeToLive -= dt;

		if( p->timeToLive > 0 ) {
			
			// Mode A: gravity, direction, tangential accel & radial accel
			if( emitterMode_ == kCCParticleModeGravity ) {
				CGPoint tmp, radial, tangential;
				
				radial = CGPointZero;
				// radial acceleration
				if(p->pos.x || p->pos.y)
					radial = ccpNormalize(p->pos);
				tangential = radial;
				radial = ccpMult(radial, p->mode.A.radialAccel);
				
				// tangential acceleration
				float newy = tangential.x;
				tangential.x = -tangential.y;
				tangential.y = newy;
				tangential = ccpMult(tangential, p->mode.A.tangentialAccel);
				
				// (gravity + radial + tangential) * dt
				tmp = ccpAdd( ccpAdd( radial, tangential), mode.A.gravity);
				tmp = ccpMult( tmp, dt);
				p->mode.A.dir = ccpAdd( p->mode.A.dir, tmp);
				tmp = ccpMult(p->mode.A.dir, dt);
				p->pos = ccpAdd( p->pos, tmp );
			}
			
			// Mode B: radius movement
			else {				
				// Update the angle and radius of the particle.
				p->mode.B.angle += p->mode.B.degreesPerSecond * dt;
				p->mode.B.radius += p->mode.B.deltaRadius * dt;
				
				p->pos.x = - cosf(p->mode.B.angle) * p->mode.B.radius;
				p->pos.y = - sinf(p->mode.B.angle) * p->mode.B.radius;
			}
			
			// color
			p->color.r += (p->deltaColor.r * dt);
			p->color.g += (p->deltaColor.g * dt);
			p->color.b += (p->deltaColor.b * dt);
			p->color.a += (p->deltaColor.a * dt);
			
			// size
			p->size += (p->deltaSize * dt);
			p->size = MAX( 0, p->size );
			
			// angle
			p->rotation += (p->deltaRotation * dt);
						
			//
			// update values in quad
			//
			
			CGPoint	newPos;
			
			if( positionType_ == kCCPositionTypeFree ) {
				CGPoint diff = ccpSub( currentPosition, p->startPos );
				newPos = ccpSub(p->pos, diff);
				
			} else
				newPos = p->pos;

			
			updateParticleImp(self, updateParticleSel, p, newPos);
			
			// update particle counter
			particleIdx++;
			
		} else {
			// life < 0
			if( particleIdx != particleCount-1 )
				particles[particleIdx] = particles[particleCount-1];
			particleCount--;
			
			if( particleCount == 0 && autoRemoveOnFinish_ ) {
				[self unscheduleUpdate];
				[parent_ removeChild:self cleanup:YES];
				return;
			}
		}
	}
	
#if CC_ENABLE_PROFILERS
	CCProfilingEndTimingBlock(_profilingTimer);
#endif
	
	[self postStep];
}

-(void) updateQuadWithParticle:(tCCParticle*)particle newPosition:(CGPoint)pos;
{
	// should be overriden
}

-(void) postStep
{
	// should be overriden
}

#pragma mark ParticleSystem - CCTexture protocol

-(void) setTexture:(CCTexture2D*) texture
{
	[texture_ release];
	texture_ = [texture retain];

	// If the new texture has No premultiplied alpha, AND the blendFunc hasn't been changed, then update it
	if( texture_ && ! [texture hasPremultipliedAlpha] &&		
	   ( blendFunc_.src == CC_BLEND_SRC && blendFunc_.dst == CC_BLEND_DST ) ) {
	
		blendFunc_.src = GL_SRC_ALPHA;
		blendFunc_.dst = GL_ONE_MINUS_SRC_ALPHA;
	}
}

-(CCTexture2D*) texture
{
	return texture_;
}

#pragma mark ParticleSystem - Additive Blending
-(void) setBlendAdditive:(BOOL)additive
{
	if( additive ) {
		blendFunc_.src = GL_SRC_ALPHA;
		blendFunc_.dst = GL_ONE;

	} else {
		
		if( texture_ && ! [texture_ hasPremultipliedAlpha] ) {
			blendFunc_.src = GL_SRC_ALPHA;
			blendFunc_.dst = GL_ONE_MINUS_SRC_ALPHA;
		} else {
			blendFunc_.src = CC_BLEND_SRC;
			blendFunc_.dst = CC_BLEND_DST;
		}
	}
}

-(BOOL) blendAdditive
{
	return( blendFunc_.src == GL_SRC_ALPHA && blendFunc_.dst == GL_ONE);
}

#pragma mark ParticleSystem - Properties of Gravity Mode 
-(void) setTangentialAccel:(float)t
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	mode.A.tangentialAccel = t;
}
-(float) tangentialAccel
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	return mode.A.tangentialAccel;
}

-(void) setTangentialAccelVar:(float)t
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	mode.A.tangentialAccelVar = t;
}
-(float) tangentialAccelVar
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	return mode.A.tangentialAccelVar;
}

-(void) setRadialAccel:(float)t
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	mode.A.radialAccel = t;
}
-(float) radialAccel
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	return mode.A.radialAccel;
}

-(void) setRadialAccelVar:(float)t
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	mode.A.radialAccelVar = t;
}
-(float) radialAccelVar
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	return mode.A.radialAccelVar;
}

-(void) setGravity:(CGPoint)g
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	mode.A.gravity = g;
}
-(CGPoint) gravity
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	return mode.A.gravity;
}

-(void) setSpeed:(float)speed
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	mode.A.speed = speed;
}
-(float) speed
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	return mode.A.speed;
}

-(void) setSpeedVar:(float)speedVar
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	mode.A.speedVar = speedVar;
}
-(float) speedVar
{
	NSAssert( emitterMode_ == kCCParticleModeGravity, @"Particle Mode should be Gravity");
	return mode.A.speedVar;
}

#pragma mark ParticleSystem - Properties of Radius Mode

-(void) setStartRadius:(float)startRadius
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	mode.B.startRadius = startRadius;
}
-(float) startRadius
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	return mode.B.startRadius;
}

-(void) setStartRadiusVar:(float)startRadiusVar
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	mode.B.startRadiusVar = startRadiusVar;
}
-(float) startRadiusVar
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	return mode.B.startRadiusVar;
}

-(void) setEndRadius:(float)endRadius
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	mode.B.endRadius = endRadius;
}
-(float) endRadius
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	return mode.B.endRadius;
}

-(void) setEndRadiusVar:(float)endRadiusVar
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	mode.B.endRadiusVar = endRadiusVar;
}
-(float) endRadiusVar
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	return mode.B.endRadiusVar;
}

-(void) setRotatePerSecond:(float)degrees
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	mode.B.rotatePerSecond = degrees;
}
-(float) rotatePerSecond
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	return mode.B.rotatePerSecond;
}

-(void) setRotatePerSecondVar:(float)degrees
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	mode.B.rotatePerSecondVar = degrees;
}

-(float) rotatePerSecondVar
{
	NSAssert( emitterMode_ == kCCParticleModeRadius, @"Particle Mode should be Radius");
	return mode.B.rotatePerSecondVar;
}

